<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>职业模拟器 - 锻造与烹饪</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        :root {
            --bg-color: #1d1f23;
            --surface-color: #282a30;
            --primary-color: #ffae42;
            --primary-dark: #ff8c00;
            --text-color: #e0e0e0;
            --text-muted: #9e9e9e;
            --craftsman-glow: rgba(255, 165, 0, 0.8);
            --rarity-rare-bg: #3949ab; /* Indigo for Rare */
            --rarity-rare-plus-bg: linear-gradient(45deg, #3949ab, #8e24aa); /* Indigo to Purple for Rare+ */
            --rarity-elite-bg: #8e24aa; /* Purple for Elite */
            --score-0: #ef5350;
            --score-1: #66bb6a;
            --score-2: #42a5f5;
            --score-3: #ab47bc;
            --score-4: #ffd700;
        }

        body {
            font-family: 'Poppins', 'Noto Sans SC', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        #background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .spark, .bubble {
            position: absolute;
            bottom: -50px;
            border-radius: 50%;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            opacity: 0;
        }

        .spark {
            background-color: var(--primary-color);
            animation-name: rise;
        }
        
        .bubble {
            background-color: rgba(255, 255, 255, 0.15);
            animation-name: bubble-rise;
            border: 1px solid rgba(255, 255, 255, 0.25);
        }

        @keyframes rise {
            0% { transform: translateY(0) scale(0); opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-110vh) scale(1); opacity: 0; }
        }

        @keyframes bubble-rise {
            0% { transform: translateY(0) scale(0.5); opacity: 0.7; }
            50% { transform: translateX(20px); }
            90% { opacity: 0.7; }
            100% { transform: translateY(-110vh) scale(1.2); opacity: 0; }
        }

        .container {
            width: 100%;
            max-width: 1100px;
            background: rgba(40, 42, 48, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37), 0 0 25px rgba(255, 174, 66, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.18);
            max-height: 95vh;
            overflow-y: auto;
        }

        h1, h2, h3 {
            text-align: center;
            color: var(--primary-color);
            text-shadow: 0 0 8px var(--craftsman-glow);
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 25px;
        }
        h3 {
            font-size: 1.4em;
            color: var(--text-color);
            text-shadow: none;
            border-bottom: 1px solid var(--surface-color);
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        
        h4 {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .main-title-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 15px;
        }
        .main-title-container h1 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
            flex-grow: 1;
        }
        .switch-role-button {
            background: var(--surface-color);
            color: var(--text-muted);
            border: 1px solid var(--surface-color);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .switch-role-button:hover {
            background: var(--bg-color);
            color: var(--text-color);
            border-color: var(--text-muted);
        }

        #role-selection-screen { text-align: center; }
        .role-options { display: flex; justify-content: center; gap: 30px; margin-top: 30px; }
        .role-card {
            background: var(--surface-color); padding: 30px; border-radius: 15px;
            cursor: pointer; transition: transform 0.3s ease, box-shadow 0.3s ease; width: 200px;
        }
        .role-card:hover { transform: translateY(-10px); box-shadow: 0 15px 30px rgba(0,0,0,0.5); }
        .role-icon { font-size: 4em; }
        .role-name { font-size: 1.5em; font-weight: 600; margin-top: 15px; }
        .role-actions { margin-top: 30px; display: flex; justify-content: center; gap: 15px; }

        .main-layout { display: flex; gap: 30px; flex-wrap: wrap; }
        .left-panel { flex: 1.2; min-width: 320px; }
        .right-panel { flex: 2; min-width: 450px; }

        .setup-section {
            background: var(--surface-color); padding: 20px; border-radius: 12px;
            margin-bottom: 20px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .recipe-selector label { font-size: 1.2em; margin-bottom: 10px; display: block; }

        .custom-select-container { position: relative; }
        #custom-select-trigger {
            width: 100%; padding: 12px; border-radius: 8px; background-color: var(--bg-color);
            color: var(--text-color); border: 1px solid rgba(255,255,255,0.1); font-size: 1em;
            cursor: pointer; display: flex; justify-content: space-between; align-items: center;
        }
        #custom-select-trigger::after { content: '▼'; font-size: 0.8em; transition: transform 0.3s ease; }
        .custom-select-container.open #custom-select-trigger::after { transform: rotate(180deg); }
        #custom-select-options {
            position: absolute; top: 105%; left: 0; width: 100%; background-color: var(--bg-color);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; z-index: 10;
            overflow: hidden; transform-origin: top; transition: transform 0.3s ease, opacity 0.3s ease;
            transform: scaleY(0); opacity: 0;
        }
        .custom-select-container.open #custom-select-options { transform: scaleY(1); opacity: 1; }
        .custom-select-option {
            padding: 12px; cursor: pointer; transition: background-color 0.2s;
            display: flex; justify-content: space-between; align-items: center;
        }
        .custom-select-option:hover { background-color: var(--surface-color); }
        .recipe-label { font-weight: 600; padding: 3px 8px; border-radius: 6px; font-size: 0.8em; color: #fff; }
        
        #recipe-details { margin-top: 15px; }
        #recipe-difficulty {
            font-weight: 600; padding: 5px 12px; border-radius: 8px; display: inline-block;
            font-size: 0.9em; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .rarity-rare { background-color: var(--rarity-rare-bg); }
        .rarity-rare-plus { background-image: var(--rarity-rare-plus-bg); }
        .rarity-elite { background-color: var(--rarity-elite-bg); }
        
        #recipe-description { font-size: 0.95em; color: var(--text-muted); margin-top: 10px; padding: 0 5px; }

        .strategy-section {
            background-color: rgba(0,0,0,0.2); border-left: 4px solid var(--primary-color);
            padding: 12px 15px; margin-top: 15px; border-radius: 5px;
        }
        .strategy-tabs { display: flex; gap: 10px; margin-bottom: 10px; }
        .strategy-tab {
            background: none; border: 1px solid var(--text-muted); color: var(--text-muted);
            padding: 5px 12px; border-radius: 15px; cursor: pointer; transition: all 0.2s;
        }
        .strategy-tab.active { background-color: var(--primary-color); color: var(--bg-color); border-color: var(--primary-color); font-weight: 600; }
        #strategy-display { display: flex; flex-direction: column; align-items: center; }
        #strategy-cards-container { display: flex; justify-content: center; flex-wrap: wrap; }
        #strategy-cards-container .card { transform: scale(0.7); margin: -15px -10px; pointer-events: none; }
        #apply-strategy-btn {
            background-color: var(--primary-dark); color: #fff; border: none;
            padding: 6px 14px; border-radius: 8px; cursor: pointer;
            margin-top: 10px; transition: background-color 0.2s;
        }
        #apply-strategy-btn:hover { background-color: var(--primary-color); }

        .card-selection-area { display: flex; flex-direction: column; gap: 20px; }
        .card-list {
            background-color: rgba(0,0,0,0.2); padding: 15px; border-radius: 12px;
            min-height: 220px; border: 1px dashed var(--text-muted); perspective: 1000px;
        }
        #card-pool-container, #deck-config-container { display: flex; flex-wrap: wrap; gap: 10px; }

        .card {
            border-radius: 10px; cursor: pointer; user-select: none;
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            border: 1px solid rgba(0,0,0,0.5); display: flex; flex-direction: column;
            justify-content: space-between; align-items: center; width: 100px; height: 130px;
            padding: 10px 5px; box-sizing: border-box;
            background-image: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.2));
            position: relative; overflow: hidden;
        }
        
        @keyframes shine { from { left: -80%; } to { left: 130%; } }
        .card:hover::before {
            content: ''; position: absolute; top: 0; left: -80%; width: 50%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: skewX(-25deg); animation: shine 0.7s ease;
        }
        .card:hover { transform: translateY(-10px) rotateX(10deg) rotateY(-5deg) scale(1.1); box-shadow: 0 15px 25px rgba(0,0,0,0.4); }
        
        .card-icon { width: 40%; height: 40%; display: flex; align-items: center; justify-content: center; }
        .card-icon svg { width: 100%; height: 100%; fill: rgba(255,255,255,0.8); filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5)); }
        .card-name { font-weight: 600; font-size: 1em; line-height: 1.2; }
        .card-desc { font-size: 0.7em; color: var(--text-muted); line-height: 1.3; }

        @keyframes molten-core {
            0% { box-shadow: 0 0 8px 2px #ff8c00, inset 0 0 5px 1px #ffae42; }
            50% { box-shadow: 0 0 16px 5px #ffae42, inset 0 0 10px 3px #ff8c00; }
            100% { box-shadow: 0 0 8px 2px #ff8c00, inset 0 0 5px 1px #ffae42; }
        }
        @keyframes card-enter { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }
        .card-enter-active { animation: card-enter 0.3s ease-out; }

        .card.forging, .card.skilled-forging, .card.fire-control { border: 1px solid var(--primary-dark); animation: molten-core 2.5s infinite ease-in-out; }
        .card.forging:hover, .card.skilled-forging:hover, .card.fire-control:hover { box-shadow: 0 15px 30px rgba(255, 140, 0, 0.5); }
        .card.forging { background-color: #a1583b; } 
        .card.skilled-forging { background-color: #d15532; }
        .card.ignition { background-color: #b71c1c; }
        .card.heating-up { background-color: #ff6f00; }
        .card.focusing-energy { background-color: #5e35b1; }
        .card.fire-control { background-color: #d15532; }
        .card.cutting { background-color: #0277bd; }
        .card.seasoning { background-color: #b71c1c; }
        .card.slow-cook { background-color: #5e35b1; }
        
        #deck-config-container .card.forging, #deck-config-container .card.skilled-forging, #deck-config-container .card.fire-control { animation: none; }
        .empty-card-slot {
            background: transparent;
            border: 2px dashed var(--surface-color);
            cursor: default;
        }
        .empty-card-slot:hover { transform: none; box-shadow: none; }
        .empty-card-slot::before { display: none; }
        
        #start-forge-btn {
            display: block; width: 100%; padding: 18px; font-size: 1.5em; font-weight: 700;
            color: #fff; background: linear-gradient(45deg, var(--primary-dark), var(--primary-color));
            border: none; border-radius: 10px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px; text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }
        #start-forge-btn:disabled { background: #546e7a; cursor: not-allowed; color: #90a4ae; box-shadow: none; }
        #start-forge-btn:not(:disabled):hover { transform: translateY(-3px); box-shadow: 0 4px 20px rgba(255, 140, 0, 0.5); }
        #start-forge-btn:not(:disabled):active { transform: translateY(0); }
        
        #game-screen { display: none; }
        .score-display { display: flex; justify-content: space-around; margin: 20px 0; font-size: clamp(1.5em, 5vw, 2em); font-weight: bold; }
        .score-display > div > span { display: inline-block; transition: transform 0.2s ease; }
        .purple-score { color: #c398ff; }
        .blue-score { color: #8cb9ff; }
        
        @keyframes score-update-animation {
            0% { transform: scale(1); } 50% { transform: scale(1.5); color: #fff; text-shadow: 0 0 10px #fff; } 100% { transform: scale(1); }
        }
        @keyframes final-score-pop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .score-updated { animation: score-update-animation 0.5s ease-out; }
        #final-score.score-updated { animation: final-score-pop 0.3s ease-out; }

        #log {
            background-color: #1e2124; height: 250px; overflow-y: auto; border-radius: 5px;
            padding: 15px; font-family: 'Courier New', Courier, monospace; border: 1px solid #40444b;
            margin-bottom: 20px; white-space: pre-wrap; font-size: 0.9em;
        }
        
        #final-score {
            font-size: clamp(2em, 7vw, 2.5em); font-weight: bold; color: #4caf50;
            text-shadow: 0 0 10px #4caf50; display: inline-block; transition: color 0.3s;
        }
        #final-score-container { text-align: center; }

        .star-rating { text-align: center; font-size: 2.5em; margin-top: -10px; margin-bottom: 20px; }
        .star { color: #444; transition: color 0.3s, transform 0.3s; display: inline-block; position: relative;}
        .star.filled { color: #ffd700; text-shadow: 0 0 5px #ffd700; }
        
        @keyframes star-pop-in { 0% { transform: scale(0); opacity: 0; } 50% { transform: scale(1.5); opacity: 1; } 100% { transform: scale(1); } }
        .star.newly-filled { animation: star-pop-in 0.5s ease-out; }
        
        @keyframes up-and-fade {
            0% { transform: translateY(0) scale(0.8); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }

        .star.newly-filled::after {
            content: 'UP!';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.4em;
            font-weight: bold;
            color: var(--primary-color);
            text-shadow: 0 0 5px white;
            animation: up-and-fade 1s ease-out forwards;
        }

        .action-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
        .action-buttons button {
            padding: 12px 25px; font-size: 1.2em; font-weight: 600; cursor: pointer;
            border-radius: 8px; border: none; transition: all 0.2s;
        }
        #forge-again-btn { background-color: var(--primary-dark); color: #fff; }
        #forge-again-btn:hover { background-color: var(--primary-color); transform: translateY(-2px); }
        #change-recipe-btn { background-color: #607d8b; color: #fff; }
        #change-recipe-btn:hover { background-color: #78909c; transform: translateY(-2px); }
        #reset-btn { background-color: #7289da; color: #fff; }
        #reset-btn:hover { background-color: #8c9eff; transform: translateY(-2px); }
        
        /* History Section */
        .history-header { display: flex; justify-content: space-between; align-items: center; }
        .delete-btn {
            background: none; border: 1px solid #c62828; color: #c62828;
            padding: 4px 10px; font-size: 0.8em; border-radius: 5px; cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .delete-btn:hover { background-color: #c62828; color: #fff; }
        #history-list { max-height: 200px; overflow-y: auto; margin-top: 10px; padding-right: 5px; }
        .history-item {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid var(--surface-color);
        }
        .history-item-header {
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            overflow: hidden;
        }
        .history-item-cards {
            flex-grow: 1;
            flex-shrink: 1;
            display: flex;
            align-items: center;
            flex-wrap: nowrap;
            min-width: 0;
        }
         .history-item-cards[data-count-gt-3="true"] {
            overflow-x: auto;
        }
        .history-item-cards::-webkit-scrollbar {
            height: 4px;
        }
        .history-item-cards::-webkit-scrollbar-track {
            background: transparent;
        }
        .history-item-cards::-webkit-scrollbar-thumb {
            background-color: var(--surface-color);
            border-radius: 2px;
        }
        .history-item-cards .card {
            transform: scale(0.5);
            margin: -25px -20px;
            pointer-events: none;
            flex-shrink: 0;
        }
        .history-item-score {
            font-size: 1.1em;
            font-weight: 600;
            text-align: right;
            white-space: nowrap;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            padding-left: 10px;
        }
        .history-item-stars {
            font-size: 0.9em;
            color: var(--primary-color);
            margin-top: 2px;
        }
        .history-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }
        .history-item.expanded .history-details {
            max-height: 300px;
        }
        .history-log {
            background: var(--bg-color);
            padding: 10px;
            margin: 0 10px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--surface-color);
        }


        /* Confirmation Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }
        .modal-box {
            background: var(--surface-color); padding: 30px; border-radius: 15px;
            text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #modal-message { font-size: 1.2em; margin-bottom: 25px; }
        .modal-buttons { display: flex; gap: 15px; justify-content: center; }
        .modal-btn {
            padding: 10px 25px; border-radius: 8px; border: none;
            font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s;
        }
        .modal-btn:hover { transform: scale(1.05); }
        .modal-btn.confirm { background-color: #c62828; color: #fff; }
        .modal-btn.cancel { background-color: #4f4f4f; color: var(--text-color); }

        /* Handbook */
        #handbook-nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .handbook-nav-btn {
            background: var(--surface-color);
            color: var(--text-muted);
            border: 1px solid var(--surface-color);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .handbook-nav-btn.active {
            background-color: var(--primary-color);
            color: var(--bg-color);
            border-color: var(--primary-color);
            font-weight: 600;
        }
        #handbook-nav .nav-spacer {
            width: 30px;
        }
        .handbook-card-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .handbook-card-count {
            font-size: 1.2em;
            font-weight: 600;
        }
        .handbook-recipe-item {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--surface-color);
        }
        .handbook-strategy-container { margin-top: 10px; }
        .handbook-recipe-tabs { display: flex; gap: 8px; margin-bottom: 10px; }
        .handbook-recipe-tab {
             background: none; border: 1px solid var(--text-muted); color: var(--text-muted);
            padding: 4px 10px; border-radius: 12px; cursor: pointer; transition: all 0.2s;
            font-size: 0.8em;
        }
        .handbook-recipe-tab.active {
            background-color: var(--primary-color); color: var(--bg-color); border-color: var(--primary-color); font-weight: 600;
        }
        .handbook-recipe-deck { display: flex; }
        .handbook-section p {
            line-height: 1.8;
            color: var(--text-muted);
        }
        .handbook-section ul {
            list-style: none;
            padding-left: 0;
        }
        .handbook-section li {
            margin-bottom: 8px;
        }
        .handbook-role-rules {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .score-color-0 { color: var(--score-0); text-shadow: 0 0 10px var(--score-0); }
        .score-color-1 { color: var(--score-1); text-shadow: 0 0 10px var(--score-1); }
        .score-color-2 { color: var(--score-2); text-shadow: 0 0 10px var(--score-2); }
        .score-color-3 { color: var(--score-3); text-shadow: 0 0 10px var(--score-3); }
        .score-color-4 { color: var(--score-4); text-shadow: 0 0 10px var(--score-4); }

    </style>
</head>
<body>
    <div id="background-container"></div>
    <div class="container">
        <!-- Role Selection Screen -->
        <div id="role-selection-screen">
            <h1>选择你的职业</h1>
            <div class="role-options">
                <div class="role-card" data-role="forge">
                    <div class="role-icon">🔨</div>
                    <div class="role-name">锻造工匠</div>
                </div>
                <div class="role-card" data-role="chef">
                    <div class="role-icon">🍳</div>
                    <div class="role-name">厨师</div>
                </div>
            </div>
            <div class="role-actions">
                <button id="handbook-btn" class="switch-role-button">职业手册</button>
                <button id="delete-all-history-btn-role" class="delete-btn">清空所有记录</button>
            </div>
        </div>

        <!-- Handbook Screen -->
        <div id="handbook-screen" style="display: none;">
            <div class="main-title-container">
                <h1>职业手册</h1>
                <button id="close-handbook-btn" class="switch-role-button">返回</button>
            </div>
            <div id="handbook-nav"></div>
            <div id="handbook-content" style="max-height: 65vh; overflow-y: auto; padding-right: 15px;"></div>
        </div>


        <!-- Setup Screen -->
        <div id="setup-screen" style="display: none;">
            <div class="main-title-container">
                <h1 id="main-title"></h1>
                <button id="switch-role-btn" class="switch-role-button">切换职业</button>
            </div>
            <div class="main-layout">
                <div class="left-panel">
                    <div class="setup-section">
                        <div class="recipe-selector">
                            <label id="recipe-select-label" for="recipe-select"></label>
                             <div class="custom-select-container" id="custom-select">
                                <div id="custom-select-trigger"></div>
                                <div id="custom-select-options"></div>
                            </div>
                        </div>
                        <div id="recipe-details">
                            <span id="recipe-difficulty"></span>
                            <div id="recipe-description"></div>
                            <div class="strategy-section" style="display: none;">
                                <div class="strategy-tabs"></div>
                                <div id="strategy-display">
                                    <div id="strategy-cards-container"></div>
                                    <button id="apply-strategy-btn">一键应用</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="setup-section" id="history-section">
                        <div class="history-header">
                            <h3 id="history-title"></h3>
                            <button id="delete-history-btn" class="delete-btn">清空当前</button>
                        </div>
                        <div id="history-list"></div>
                    </div>
                     <button id="start-forge-btn"></button>
                </div>
                <div class="right-panel">
                     <div class="card-selection-area">
                        <div class="card-list">
                            <h3 id="card-pool-title"></h3>
                            <div id="card-pool-container"></div>
                        </div>
                        <div class="card-list">
                            <h3 id="deck-title"></h3>
                            <div id="deck-config-container"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" style="display: none;">
            <h2 id="current-recipe-title"></h2>
            <div class="score-display">
                <div>💜 紫色: <span id="purple-score" class="purple-score">1</span></div>
                <div>💙 蓝色: <span id="blue-score" class="blue-score">1</span></div>
            </div>
            <h2 id="final-score-container">当前总分: <span id="final-score">1</span></h2>
            <div id="star-rating-container" class="star-rating"></div>
            <h3 id="log-title"></h3>
            <div id="log"></div>
            <div class="action-buttons">
                <button id="forge-again-btn"></button>
                <button id="change-recipe-btn">更换配方</button>
                <button id="reset-btn">更换职业</button>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmation-modal" class="modal-overlay" style="display: none;">
            <div class="modal-box">
                <p id="modal-message"></p>
                <div class="modal-buttons">
                    <button id="modal-confirm-btn" class="modal-btn confirm">确认</button>
                    <button id="modal-cancel-btn" class="modal-btn cancel">取消</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DATA ---
        const ROLES = {
            forge: {
                title: "锻造工匠模拟器", recipeLabel: "选择你的配方:", historyTitle: "锻造史记", cardPoolTitle: "卡牌仓库", deckTitle: "配置卡组", startButton: "开始锻造", logTitle: "锻造日志", againButton: "再次锻造", historyKey: "forgeHistory",
                recipes: {
                    "铜制刻刀": { slots: 3, description: "每次生产可配置3张卡牌", difficulty: "稀有", rarityKey: "rare", ratings: [6, 8], strategies: { high: ["锻造", "锻造", "锻造"], stable: ["锻造", "升温", "熟练锻造"], burst: ["锻造", "锻造", "点火"], recommended: 'high' } },
                    "铜制面罩": { slots: 4, description: "每次生产可配置4张卡牌", difficulty: "稀有+", rarityKey: "rare-plus", ratings: [19, 23], strategies: { high: ["锻造", "锻造", "升温", "熟练锻造"], stable: ["锻造", "锻造", "锻造", "锻造"], burst: ["锻造", "升温", "熟练锻造", "点火"], recommended: 'high' } },
                    "雕花木匣": { slots: 4, description: "首次打出的【锻造】卡牌将作用于全部颜色，每次可配置4张卡牌", special: "first_forge_focus", difficulty: "精英", rarityKey: "elite", ratings: [152, 180, 182, 190], strategies: { high: ["锻造", "升温", "熟练锻造", "熟练锻造"], stable: ["锻造", "升温", "锻造", "锻造"], burst: ["锻造", "升温", "升温", "点火"], recommended: 'high' } },
                    "超薄刻刀": { slots: 5, description: "每次生产可配置5张卡牌", difficulty: "精英", rarityKey: "elite", ratings: [46, 86], strategies: { high: ["锻造", "锻造", "升温", "升温", "熟练锻造"], stable: ["锻造", "锻造", "锻造", "升温", "聚能"], burst: ["锻造", "锻造", "升温", "熟练锻造", "点火"], recommended: 'high' } },
                    "木箭": { slots: 5, description: "每次生产可配置5张卡牌", difficulty: "精英", rarityKey: "elite", ratings: [108, 130, 163], strategies: { high: ["锻造", "锻造", "升温", "升温", "熟练锻造"], stable: ["锻造", "锻造", "锻造", "锻造", "锻造"], burst: ["锻造", "锻造", "升温", "熟练锻造", "点火"], recommended: 'high' } },
                    "保温铜锅": { slots: 5, description: "熟练锻造有30%的概率额外触发1次", special: "skilled_forge_echo", difficulty: "精英", rarityKey: "elite", ratings: [566, 675, 797, 1040], strategies: { high: ["锻造", "升温", "升温", "熟练锻造", "熟练锻造"], stable: ["锻造", "升温", "聚能", "熟练锻造", "熟练锻造"], burst: ["锻造", "升温", "熟练锻造", "熟练锻造", "点火"], recommended: 'high' } }
                },
                icons: { anvil: `<svg viewBox="0 0 24 24"><path d="M22.39 10.44l-1.42-1.43c-.59-.58-1.55-.58-2.12 0l-1.58 1.58-1.29-1.29-2.2-2.2c-.39-.39-1.02-.39-1.41 0l-1.42 1.42c-.39.39-.39 1.02 0 1.41l2.2 2.2 1.29 1.29-9.2 9.2c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0l9.2-9.2 1.58 1.58c.29.29.68.44 1.06.44s.77-.15 1.06-.44l1.42-1.42c.58-.59.58-1.55 0-2.12zM5.21 10.71L2.41 7.9c-1.17-1.17-1.17-3.07 0-4.24 1.17-1.17 3.07-1.17 4.24 0l2.81 2.81-4.25 4.24z"/></svg>`, fire: `<svg viewBox="0 0 24 24"><path d="M13.04 1.23C11.93 2.66 11.25 4.5 11.25 6.5c0 3.59 2.91 6.5 6.5 6.5 1.08 0 2.09-.26 3-.73-.23 3.3-2.11 6.2-4.75 7.73-3.21 1.88-7.29 1.15-9.64-1.2-2.35-2.35-3.08-6.43-1.2-9.64C7.04 6.78 9.94 4.9 13.24 4.67c-.2-.93-.4-1.87-.2-2.73.08-.34.2-.67.4-.91z"/></svg>`, crystal: `<svg viewBox="0 0 24 24"><path d="M12 2L2 8.5v7L12 22l10-6.5v-7L12 2zm0 2.31L19.69 9 12 13.53 4.31 9 12 4.31zM4 10.08l7 4.38v5.23l-7-4.38v-5.23zm9 0v5.23l7-4.38v-5.23l-7 4.38z"/></svg>`, spark: `<svg viewBox="0 0 24 24"><path d="M12 2l2.35 7.16h7.65l-6.18 4.48 2.36 7.16-6.18-4.48-6.18 4.48 2.36-7.16-6.18-4.48h7.65L12 2z"/></svg>` },
                library: {
                    "锻造": { count: 3, name: "锻造", type: "craftsman", class: "forging", description: "随机颜色+5", icon: "anvil" }, "熟练锻造": { count: 3, name: "熟练锻造", type: "craftsman", class: "skilled-forging", description: "随机颜色+3，后续所有【熟练锻造】额外+3", icon: "anvil" },
                    "升温": { count: 2, name: "升温", type: "buff", class: "heating-up", description: "后续所有工匠牌效果+3", icon: "fire" }, "聚能": { count: 2, name: "聚能", type: "utility", class: "focusing-energy", description: "下一张工匠牌作用于所有颜色", icon: "crystal" },
                    "点火": { count: 1, name: "点火", type: "multiplier", class: "ignition", description: "随机颜色x2", icon: "spark" }
                }
            },
            chef: {
                title: "厨师模拟器", recipeLabel: "选择你的菜谱:", historyTitle: "烹饪日志", cardPoolTitle: "工艺仓库", deckTitle: "工艺配置", startButton: "开始烹饪", logTitle: "烹饪日志", againButton: "再次烹饪", historyKey: "chefHistory",
                recipes: {
                    "圆面包": { slots: 3, description: "每次生产可配置3张卡牌", difficulty: "稀有", rarityKey: "rare", ratings: [6, 8], strategies: { high: ["慢炖", "火候掌握", "火候掌握"], stable: ["慢炖", "火候掌握", "切割"], burst: ["火候掌握", "火候掌握", "调味"], recommended: 'high' } },
                    "烤薄饼": { slots: 4, description: "每次生产可配置4张卡牌", difficulty: "稀有+", rarityKey: "rare-plus", ratings: [15, 25], strategies: { high: ["慢炖", "慢炖", "火候掌握", "火候掌握"], stable: ["慢炖", "火候掌握", "火候掌握", "切割"], burst: ["慢炖", "火候掌握", "火候掌握", "调味"], recommended: 'high' } },
                    "吐司": { slots: 5, description: "每次生产可配置5张卡牌", difficulty: "稀有+", rarityKey: "rare-plus", ratings: [101, 159], strategies: { high: ["慢炖", "慢炖", "火候掌握", "火候掌握", "火候掌握"], stable: ["慢炖", "慢炖", "火候掌握", "火候掌握", "切割"], burst: ["慢炖", "慢炖", "火候掌握", "火候掌握", "调味"], recommended: 'high' } },
                    "香辣面包": { slots: 5, description: "每次生产可配置5张卡牌", difficulty: "精英", rarityKey: "elite", ratings: [372, 448, 635], strategies: { high: ["慢炖", "慢炖", "火候掌握", "火候掌握", "火候掌握"], stable: ["慢炖", "慢炖", "火候掌握", "火候掌握", "切割"], burst: ["慢炖", "慢炖", "火候掌握", "火候掌握", "调味"], recommended: 'high' } },
                    "盐渍葡萄干": { slots: 4, description: "切割始终获得最高分，每次生产可配4张卡牌", special: "max_cutting", difficulty: "精英", rarityKey: "elite", ratings: [344, 440, 462, 647], strategies: { high: ["切割", "切割", "切割", "调味"], stable: ["慢炖", "火候掌握", "切割", "切割"], burst: ["切割", "切割", "切割", "调味"], recommended: 'burst' } },
                    "葡萄果醋": { slots: 6, description: "每次生产可配置6张卡牌", difficulty: "精英", rarityKey: "elite", ratings: [1070, 1270, 1420, 1740], strategies: { high: ["慢炖", "慢炖", "火候掌握", "火候掌握", "火候掌握", "火候掌握"], stable: ["慢炖", "慢炖", "火候掌握", "火候掌握", "切割", "切割"], burst: ["慢炖", "慢炖", "火候掌握", "火候掌握", "火候掌握", "调味"], recommended: 'high' } }
                },
                icons: { fire: `<svg viewBox="0 0 24 24"><path d="M13.04 1.23C11.93 2.66 11.25 4.5 11.25 6.5c0 3.59 2.91 6.5 6.5 6.5 1.08 0 2.09-.26 3-.73-.23 3.3-2.11 6.2-4.75 7.73-3.21 1.88-7.29 1.15-9.64-1.2-2.35-2.35-3.08-6.43-1.2-9.64C7.04 6.78 9.94 4.9 13.24 4.67c-.2-.93-.4-1.87-.2-2.73.08-.34.2-.67.4-.91z"/></svg>`, knife: `<svg viewBox="0 0 24 24"><path d="M14.29,1.71a1,1,0,0,0-1.41,0L3.29,11.29a1,1,0,0,0,0,1.41l8,8a1,1,0,0,0,1.41,0l9.59-9.59a1,1,0,0,0,0-1.41ZM12.59,19.59L5.41,12.41,14.71,3.12l7.17,7.17Z"/></svg>`, spark: `<svg viewBox="0 0 24 24"><path d="M12 2l2.35 7.16h7.65l-6.18 4.48 2.36 7.16-6.18-4.48-6.18 4.48 2.36-7.16-6.18-4.48h7.65L12 2z"/></svg>`, pot: `<svg viewBox="0 0 24 24"><path d="M19,4H5A3,3,0,0,0,2,7V17a3,3,0,0,0,3,3H19a3,3,0,0,0,3-3V7A3,3,0,0,0,19,4Zm1,13a1,1,0,0,1-1,1H5a1,1,0,0,1-1-1V7A1,1,0,0,1,5,6H19a1,1,0,0,1,1,1Z"/></svg>` },
                library: {
                    "火候掌握": { count: 4, name: "火候掌握", type: "craftsman", class: "fire-control", description: "随机颜色+3，50%概率重复触发", icon: "fire" },
                    "切割": { count: 3, name: "切割", type: "utility", class: "cutting", description: "随机颜色+4~8", icon: "knife" },
                    "调味": { count: 1, name: "调味", type: "multiplier", class: "seasoning", description: "随机颜色x2", icon: "spark" },
                    "慢炖": { count: 2, name: "慢炖", type: "buff", class: "slow-cook", description: "触发火候掌握时触发，全部颜色+2", icon: "pot" }
                }
            }
        };

        let currentRole = null;
        let currentRecipe = null;
        let cardPool = {};
        let currentDeck = [];
        let simulationRunning = false;
        let lastStarCount = 0;
        let confirmCallback = null;
        
        const roleSelectionScreen = document.getElementById('role-selection-screen');
        const customSelect = document.getElementById('custom-select');
        const customSelectTrigger = document.getElementById('custom-select-trigger');
        const customSelectOptions = document.getElementById('custom-select-options');
        const recipeDifficultyEl = document.getElementById('recipe-difficulty');
        const recipeDescriptionEl = document.getElementById('recipe-description');
        const strategySection = document.querySelector('.strategy-section');
        const strategyTabsContainer = document.querySelector('.strategy-tabs');
        const strategyCardsContainer = document.getElementById('strategy-cards-container');
        const applyStrategyBtn = document.getElementById('apply-strategy-btn');
        const cardPoolContainer = document.getElementById('card-pool-container');
        const deckConfigContainer = document.getElementById('deck-config-container');
        const deckTitleEl = document.getElementById('deck-title');
        const startBtn = document.getElementById('start-forge-btn');
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const currentRecipeTitle = document.getElementById('current-recipe-title');
        const purpleScoreEl = document.getElementById('purple-score');
        const blueScoreEl = document.getElementById('blue-score');
        const logEl = document.getElementById('log');
        const finalScoreEl = document.getElementById('final-score');
        const finalScoreContainer = document.getElementById('final-score-container');
        const starRatingContainer = document.getElementById('star-rating-container');
        const forgeAgainBtn = document.getElementById('forge-again-btn');
        const resetBtn = document.getElementById('reset-btn');
        const changeRecipeBtn = document.getElementById('change-recipe-btn');
        const historySection = document.getElementById('history-section');
        const historyListEl = document.getElementById('history-list');
        const deleteHistoryBtn = document.getElementById('delete-history-btn');
        const deleteAllHistoryBtnRole = document.getElementById('delete-all-history-btn-role');
        const switchRoleBtn = document.getElementById('switch-role-btn');
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const handbookBtn = document.getElementById('handbook-btn');
        const handbookScreen = document.getElementById('handbook-screen');
        const closeHandbookBtn = document.getElementById('close-handbook-btn');
        const handbookContent = document.getElementById('handbook-content');
        const handbookNav = document.getElementById('handbook-nav');
        const backgroundContainer = document.getElementById('background-container');

        function init() {
            document.querySelectorAll('.role-card').forEach(card => card.addEventListener('click', () => selectRole(card.dataset.role)));
            customSelectTrigger.addEventListener('click', () => customSelect.classList.toggle('open'));
            window.addEventListener('click', (e) => { if (!customSelect.contains(e.target)) customSelect.classList.remove('open'); });
            startBtn.addEventListener('click', runSimulation);
            forgeAgainBtn.addEventListener('click', runSimulation);
            changeRecipeBtn.addEventListener('click', resetToSetupScreen);
            resetBtn.addEventListener('click', resetToRoleSelection);
            switchRoleBtn.addEventListener('click', resetToRoleSelection);
            deleteHistoryBtn.addEventListener('click', deleteCurrentHistory);
            deleteAllHistoryBtnRole.addEventListener('click', deleteAllHistory);
            modalConfirmBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); hideConfirmationModal(); });
            modalCancelBtn.addEventListener('click', hideConfirmationModal);
            confirmationModal.addEventListener('click', (e) => { if (e.target === confirmationModal) hideConfirmationModal(); });
            handbookBtn.addEventListener('click', showHandbook);
            closeHandbookBtn.addEventListener('click', hideHandbook);
        }
        
        function selectRole(roleKey) {
            currentRole = ROLES[roleKey];
            roleSelectionScreen.style.display = 'none';
            setupScreen.style.display = 'block';
            historySection.style.display = 'block';
            
            generateBackground(roleKey);
            
            document.getElementById('main-title').textContent = currentRole.title;
            document.getElementById('recipe-select-label').textContent = currentRole.recipeLabel;
            document.getElementById('history-title').textContent = currentRole.historyTitle;
            document.getElementById('card-pool-title').textContent = currentRole.cardPoolTitle;
            document.getElementById('deck-title').textContent = currentRole.deckTitle;
            document.getElementById('start-forge-btn').textContent = currentRole.startButton;
            document.getElementById('log-title').textContent = currentRole.logTitle;
            document.getElementById('forge-again-btn').textContent = currentRole.againButton;

            customSelectOptions.innerHTML = '';
            Object.keys(currentRole.recipes).forEach(name => {
                const recipe = currentRole.recipes[name];
                const optionEl = document.createElement('div');
                optionEl.className = 'custom-select-option';
                optionEl.dataset.value = name;
                optionEl.innerHTML = `<span>${name}</span><span class="recipe-label rarity-${recipe.rarityKey}">${recipe.difficulty}</span>`;
                optionEl.addEventListener('click', () => {
                    customSelectTrigger.innerHTML = `<span>${name}</span>`;
                    customSelect.classList.remove('open');
                    handleRecipeChange(name);
                });
                customSelectOptions.appendChild(optionEl);
            });
            
            const firstRecipe = Object.keys(currentRole.recipes)[0];
            customSelectTrigger.innerHTML = `<span>${firstRecipe}</span>`;
            handleRecipeChange(firstRecipe);
        }

        function handleRecipeChange(recipeName) {
            currentRecipe = currentRole.recipes[recipeName];
            
            recipeDifficultyEl.textContent = currentRecipe.difficulty;
            recipeDifficultyEl.className = '';
            recipeDifficultyEl.classList.add(`rarity-${currentRecipe.rarityKey}`);
            recipeDescriptionEl.textContent = currentRecipe.description;

            setupStrategyTabs(recipeName);

            resetCardSelection();
            updateUI();
            renderHistory(recipeName);
        }
        
        function setupStrategyTabs(recipeName) {
            const strategies = currentRole.recipes[recipeName].strategies;
            if (strategies) {
                strategySection.style.display = 'block';
                strategyTabsContainer.innerHTML = `
                    <button class="strategy-tab" data-strategy="recommended">推荐</button>
                    <button class="strategy-tab" data-strategy="high">高分</button>
                    <button class="strategy-tab" data-strategy="stable">稳定</button>
                    <button class="strategy-tab" data-strategy="burst">爆发</button>
                `;
                
                const tabs = strategyTabsContainer.querySelectorAll('.strategy-tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        tabs.forEach(t => t.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        renderStrategyDeck(e.currentTarget.dataset.strategy);
                    });
                });
                
                const recommendedTab = strategyTabsContainer.querySelector(`[data-strategy="recommended"]`);
                recommendedTab.classList.add('active');
                renderStrategyDeck('recommended');

            } else {
                strategySection.style.display = 'none';
            }
        }
        
        function renderStrategyDeck(strategyType) {
            let deckKey = strategyType;
            if (strategyType === 'recommended') {
                deckKey = currentRecipe.strategies.recommended;
            }
            const deck = currentRecipe.strategies[deckKey];
            strategyCardsContainer.innerHTML = '';
            if (deck) {
                deck.forEach(cardName => {
                    const cardInfo = currentRole.library[cardName];
                    if (cardInfo) {
                        strategyCardsContainer.appendChild(createCardElement(cardInfo, 'tip'));
                    }
                });
            }
            applyStrategyBtn.onclick = () => applyStrategy(deckKey);
        }
        
        function applyStrategy(strategyType) {
            const deckToApply = currentRecipe.strategies[strategyType];
            if (!deckToApply) return;

            const existingCards = deckConfigContainer.querySelectorAll('.card');
            existingCards.forEach(card => {
                card.style.opacity = '0';
                card.style.transform = 'scale(0.5)';
            });

            setTimeout(() => {
                resetCardSelection();
                
                for (const cardName of deckToApply) {
                    if(cardPool[cardName] && cardPool[cardName].count > 0) {
                        cardPool[cardName].count--;
                        currentDeck.push(cardName);
                    }
                }
                
                updateUI();
                
                const newCards = deckConfigContainer.querySelectorAll('.card');
                newCards.forEach((card, index) => {
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.5)';
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            card.classList.add('card-enter-active');
                            card.style.opacity = '1';
                            card.style.transform = 'scale(1)';
                        }, index * 50);
                    });
                });
            }, existingCards.length > 0 ? 300 : 0);
        }


        function resetCardSelection() {
            cardPool = JSON.parse(JSON.stringify(currentRole.library));
            currentDeck = [];
        }

        function updateUI() {
            cardPoolContainer.innerHTML = '';
            for (const name in cardPool) {
                const card = cardPool[name];
                if (card.count > 0) {
                    for(let i=0; i<card.count; i++) {
                        cardPoolContainer.appendChild(createCardElement(card, 'pool', `${name}-${i}`));
                    }
                }
            }

            deckConfigContainer.innerHTML = '';
            currentDeck.forEach((cardName, index) => {
                const cardInfo = Object.values(currentRole.library).find(c => c.name === cardName);
                deckConfigContainer.appendChild(createCardElement(cardInfo, 'deck', index));
            });
            
            const emptySlotsCount = currentRecipe.slots - currentDeck.length;
            for(let i = 0; i < emptySlotsCount; i++) {
                const emptyEl = document.createElement('div');
                emptyEl.className = 'card empty-card-slot';
                deckConfigContainer.appendChild(emptyEl);
            }
            
            deckTitleEl.textContent = `${currentRole.deckTitle} (${currentDeck.length}/${currentRecipe.slots})`;
            startBtn.disabled = currentDeck.length !== currentRecipe.slots;
            deckTitleEl.style.color = startBtn.disabled ? 'var(--primary-color)' : '#4caf50';
        }

        function createCardElement(cardInfo, location, uniqueId, roleContext = currentRole) {
            const el = document.createElement('div');
            el.className = `card ${cardInfo.class}`;
            el.dataset.id = uniqueId;
            el.innerHTML = `
                <div class="card-icon">${roleContext.icons[cardInfo.icon] || ''}</div>
                <div class="card-name">${cardInfo.name}</div>
                <div class="card-desc">${cardInfo.description}</div>
            `;

            if (location === 'pool') {
                el.onclick = (e) => addCardToDeck(cardInfo.name, e.currentTarget);
            } else if (location === 'deck') {
                el.onclick = (e) => removeCardFromDeck(uniqueId, e.currentTarget);
            }
            return el;
        }

        function addCardToDeck(cardName, element) {
            if (currentDeck.length >= currentRecipe.slots || cardPool[cardName].count <= 0) return;

            element.style.pointerEvents = 'none';
            element.style.opacity = '0';
            element.style.transform = 'scale(0.5)';
            
            setTimeout(() => {
                cardPool[cardName].count--;
                currentDeck.push(cardName);
                
                updateUI();
                const newDeckCard = deckConfigContainer.querySelector(`.card:nth-last-child(${currentRecipe.slots - currentDeck.length + 1})`);
                if (newDeckCard) {
                    requestAnimationFrame(() => newDeckCard.classList.add('card-enter-active'));
                }
            }, 300);
        }

        function removeCardFromDeck(index, element) {
            const cardName = currentDeck[index];
            if (!cardName) return;

            element.style.pointerEvents = 'none';
            element.style.opacity = '0';
            element.style.transform = 'scale(0.5)';

            setTimeout(() => {
                currentDeck.splice(index, 1);
                cardPool[cardName].count++;
                
                updateUI();
                const newPoolCard = Array.from(cardPoolContainer.querySelectorAll(`[data-id^="${cardName}"]`)).pop();
                 if (newPoolCard) {
                    requestAnimationFrame(() => newPoolCard.classList.add('card-enter-active'));
                }
            }, 300);
        }
        
        function showConfirmationModal(message, onConfirm) {
            modalMessage.textContent = message;
            confirmCallback = onConfirm;
            confirmationModal.style.display = 'flex';
        }

        function hideConfirmationModal() {
            confirmationModal.style.display = 'none';
            confirmCallback = null;
        }

        function updateAnimatedScore(element, value) {
            element.textContent = value.toLocaleString();
            element.classList.add('score-updated');
            element.addEventListener('animationend', () => element.classList.remove('score-updated'), { once: true });
        }

        function updateStarRating(score, container) {
            const thresholds = currentRecipe.ratings;
            const maxStars = thresholds.length;
            let currentStars = 0;
            for (const threshold of thresholds) {
                if (score >= threshold) currentStars++;
            }
            
            finalScoreEl.className = 'final-score'; // Reset
            finalScoreEl.classList.add(`score-color-${currentStars}`);

            let starHTML = '';
            for (let i = 1; i <= maxStars; i++) {
                const isFilled = i <= currentStars;
                const isNewlyFilled = isFilled && i > lastStarCount;
                starHTML += `<span class="star ${isFilled ? 'filled' : ''} ${isNewlyFilled ? 'newly-filled' : ''}">★</span>`;
            }
            container.innerHTML = starHTML;
            lastStarCount = currentStars;
            return currentStars;
        }

        function saveHistoryRecord(recipeName, record) {
            const history = JSON.parse(localStorage.getItem(currentRole.historyKey) || '{}');
            if (!history[recipeName]) {
                history[recipeName] = [];
            }
            history[recipeName].unshift(record);
            if (history[recipeName].length > 20) {
                history[recipeName].pop();
            }
            localStorage.setItem(currentRole.historyKey, JSON.stringify(history));
        }

        function renderHistory(recipeName) {
            const history = JSON.parse(localStorage.getItem(currentRole.historyKey) || '{}');
            const records = history[recipeName] || [];
            
            historyListEl.innerHTML = '';
            if (records.length === 0) {
                historyListEl.innerHTML = '<p style="text-align:center; color: var(--text-muted); font-size: 0.9em;">暂无记录</p>';
                deleteHistoryBtn.style.display = 'none';
            } else {
                deleteHistoryBtn.style.display = 'block';
                records.forEach(record => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'history-item';

                    const headerEl = document.createElement('div');
                    headerEl.className = 'history-item-header';
                    
                    const cardsDiv = document.createElement('div');
                    cardsDiv.className = 'history-item-cards';
                    if (record.deck.length > 3) {
                        cardsDiv.dataset.countGt3 = "true";
                    }
                    record.deck.forEach(cardName => {
                        const cardInfo = currentRole.library[cardName];
                        if (cardInfo) {
                            const cardEl = createCardElement(cardInfo, 'history');
                            cardsDiv.appendChild(cardEl);
                        }
                    });

                    const scoreDiv = document.createElement('div');
                    scoreDiv.className = 'history-item-score';
                    scoreDiv.innerHTML = `
                        <span>${record.finalScore.toLocaleString()} 分</span>
                        <span class="history-item-stars">★${record.stars}</span>
                    `;
                    
                    headerEl.appendChild(cardsDiv);
                    headerEl.appendChild(scoreDiv);

                    const detailsEl = document.createElement('div');
                    detailsEl.className = 'history-details';
                    detailsEl.innerHTML = `<div class="history-log">${record.log}</div>`;

                    itemEl.appendChild(headerEl);
                    itemEl.appendChild(detailsEl);
                    
                    headerEl.onclick = () => itemEl.classList.toggle('expanded');
                    historyListEl.appendChild(itemEl);
                });
            }
        }

        function deleteCurrentHistory() {
            showConfirmationModal('确定要清空当前配方的所有记录吗？', () => {
                const recipeName = customSelectTrigger.textContent;
                const history = JSON.parse(localStorage.getItem(currentRole.historyKey) || '{}');
                if (history[recipeName]) {
                    delete history[recipeName];
                    localStorage.setItem(currentRole.historyKey, JSON.stringify(history));
                    renderHistory(recipeName);
                }
            });
        }
        
        function deleteAllHistory() {
            showConfirmationModal('确定要清空所有职业的全部记录吗？此操作无法撤销。', () => {
                localStorage.removeItem(ROLES.forge.historyKey);
                localStorage.removeItem(ROLES.chef.historyKey);
                if (currentRole) {
                    renderHistory(customSelectTrigger.textContent);
                }
            });
        }

        async function runSimulation() {
            if (simulationRunning) return;
            simulationRunning = true;
            try {
                setupScreen.style.display = 'none';
                gameScreen.style.display = 'block';
                const recipeName = customSelectTrigger.textContent;
                currentRecipeTitle.textContent = recipeName;
                finalScoreContainer.childNodes[0].nodeValue = "当前总分: ";
                logEl.innerHTML = '';
                lastStarCount = 0;
                
                let purple = 1, blue = 1;
                let logContent = '';
                const addToLog = (message) => {
                    logContent += message + '\n';
                    logEl.innerHTML = logContent;
                    logEl.scrollTop = logEl.scrollHeight;
                };

                updateAnimatedScore(purpleScoreEl, purple);
                updateAnimatedScore(blueScoreEl, blue);
                updateAnimatedScore(finalScoreEl, purple * blue);
                updateStarRating(purple * blue, starRatingContainer);

                let heatingUpBuff = 0, skilledForgingPrimed = false, focusNext = false, slowCookCount = 0;
                let firstForgePlayed = false; // For雕花木匣
                
                const specialRule = currentRecipe.special;

                const shuffledDeck = [...currentDeck].sort(() => Math.random() - 0.5);
                addToLog("🔥 点火开炉！卡牌已洗牌...");
                await sleep(500);

                for (const cardName of shuffledDeck) {
                    await sleep(1200);
                    let logMessage = `🴥 打出卡牌: 【${cardName}】\n`;

                    const applyEffect = (name, isEcho = false) => {
                        let tempLog = "";
                        
                        if (name === "锻造") {
                            let bonus = 5 + heatingUpBuff;
                            if (heatingUpBuff > 0) tempLog += `   -> 升温效果, 基础+${heatingUpBuff}\n`;

                            if (specialRule === 'first_forge_focus' && !firstForgePlayed) {
                                purple += bonus;
                                blue += bonus;
                                tempLog += `   -> 📜 雕花木匣效果! 首次锻造作用于双色: 💜+${bonus}, 💙+${bonus}\n`;
                                firstForgePlayed = true; 
                            } else if (focusNext) {
                                purple += bonus;
                                blue += bonus;
                                tempLog += `   -> 💥 聚能生效! 作用于双色: 💜+${bonus}, 💙+${bonus}\n`;
                                focusNext = false;
                            } else {
                                const target = Math.random() < 0.5 ? 'purple' : 'blue';
                                if (target === 'purple') { purple += bonus; tempLog += `   -> 作用于随机颜色: 💜+${bonus}\n`; }
                                else { blue += bonus; tempLog += `   -> 作用于随机颜色: 💙+${bonus}\n`; }
                            }
                        } else if (name === "熟练锻造") {
                            let bonus = 3 + heatingUpBuff;
                            if (skilledForgingPrimed) { bonus += 3; tempLog += `   -> 触发熟练锻造连击, 基础+3\n`; } 
                            else { skilledForgingPrimed = true; tempLog += `   -> 首次打出熟练锻造, 后续的将获得强化!\n`; }
                            if (heatingUpBuff > 0) tempLog += `   -> 升温效果, 基础+${heatingUpBuff}\n`;
                            if (focusNext) {
                                purple += bonus;
                                blue += bonus;
                                tempLog += `   -> 💥 聚能生效! 作用于双色: 💜+${bonus}, 💙+${bonus}\n`;
                                focusNext = false;
                            } else {
                                const target = Math.random() < 0.5 ? 'purple' : 'blue';
                                if (target === 'purple') { purple += bonus; tempLog += `   -> 作用于随机颜色: 💜+${bonus}\n`; }
                                else { blue += bonus; tempLog += `   -> 作用于随机颜色: 💙+${bonus}\n`; }
                            }
                        } else if (name === "升温") {
                            heatingUpBuff += 3; tempLog += `   -> 🔥 炉火更旺了! 后续工匠牌效果+3\n`;
                        } else if (name === "聚能") {
                            focusNext = true; tempLog += `   -> ✨ 集中精神! 下一张工匠牌将作用于双色\n`;
                        } else if (name === "点火") {
                            const target = Math.random() < 0.5 ? 'purple' : 'blue'; if (target === 'purple') { tempLog += `   -> 注入燃料! 💜 紫色分数 ${purple} x 2 = ${purple*2}\n`; purple *= 2; } else { tempLog += `   -> 注入燃料! 💙 蓝色分数 ${blue} x 2 = ${blue*2}\n`; blue *= 2; }
                        } else if (name === "火候掌握") {
                            let trigger = true;
                            while(trigger) {
                                let bonus = 3;
                                const target = Math.random() < 0.5 ? 'purple' : 'blue';
                                if (target === 'purple') { purple += bonus; tempLog += `   -> 作用于随机颜色: 💜+${bonus}\n`; } 
                                else { blue += bonus; tempLog += `   -> 作用于随机颜色: 💙+${bonus}\n`; }

                                if (slowCookCount > 0) {
                                    for(let i = 0; i < slowCookCount; i++) {
                                        purple += 2;
                                        blue += 2;
                                        tempLog += `   -> 🍲 慢炖效果触发! 全部颜色+2\n`;
                                    }
                                }
                                
                                if (Math.random() < 0.5) {
                                    tempLog += `   -> 💥 火候绝佳! 重复触发一次!\n`;
                                    trigger = true;
                                } else {
                                    trigger = false;
                                }
                            }
                        } else if (name === "切割") {
                            let bonus = (specialRule === 'max_cutting') ? 8 : Math.floor(Math.random() * 5) + 4;
                            if (specialRule === 'max_cutting') tempLog += `   -> 📜 配方效果: 盐渍葡萄干 - 刀工精准!\n`;
                            const target = Math.random() < 0.5 ? 'purple' : 'blue';
                            if (target === 'purple') { purple += bonus; tempLog += `   -> 作用于随机颜色: 💜+${bonus}\n`; } 
                            else { blue += bonus; tempLog += `   -> 作用于随机颜色: 💙+${bonus}\n`; }
                        } else if (name === "调味") {
                            const target = Math.random() < 0.5 ? 'purple' : 'blue';
                            if (target === 'purple') { tempLog += `   -> 完美调味! 💜 紫色分数 ${purple} x 2 = ${purple*2}\n`; purple *= 2; } 
                            else { tempLog += `   -> 完美调味! 💙 蓝色分数 ${blue} x 2 = ${blue*2}\n`; blue *= 2; }
                        } else if (name === "慢炖") {
                            slowCookCount++;
                            tempLog += `   -> 🍲 开始慢炖! 后续的【火候掌握】将触发额外效果。\n`;
                        }

                        if(isEcho) logMessage += "   🔁 保温铜锅效果触发!\n";
                        logMessage += tempLog;
                    }

                    applyEffect(cardName);

                    if (currentRecipe.special === 'skilled_forge_echo' && cardName === '熟练锻造' && Math.random() < 0.30) {
                        await sleep(600);
                        applyEffect(cardName, true);
                    }
                    
                    updateAnimatedScore(purpleScoreEl, purple);
                    updateAnimatedScore(blueScoreEl, blue);
                    const currentScore = purple * blue;
                    updateAnimatedScore(finalScoreEl, currentScore);
                    updateStarRating(currentScore, starRatingContainer);
                    addToLog(logMessage);
                }

                await sleep(1000);
                const finalScore = purple * blue;
                finalScoreContainer.childNodes[0].nodeValue = "🎉 最终得分: ";
                addToLog(`\n制作完成! 最终得分: ${purple} × ${blue} = ${finalScore.toLocaleString()}`);
                
                const finalStars = updateStarRating(finalScore, starRatingContainer);
                
                saveHistoryRecord(recipeName, {
                    deck: [...currentDeck],
                    finalScore: finalScore,
                    stars: finalStars,
                    log: logContent
                });
                renderHistory(recipeName);

            } finally {
                simulationRunning = false;
            }
        }

        function resetToRoleSelection() {
            gameScreen.style.display = 'none';
            setupScreen.style.display = 'none';
            historySection.style.display = 'none';
            roleSelectionScreen.style.display = 'block';
        }
        
        function resetToSetupScreen() {
            gameScreen.style.display = 'none';
            setupScreen.style.display = 'block';
        }

        function showHandbook() {
            roleSelectionScreen.style.display = 'none';
            handbookScreen.style.display = 'block';
            
            handbookNav.innerHTML = '';
            const forgeBtn = document.createElement('button');
            forgeBtn.className = 'handbook-nav-btn active';
            forgeBtn.textContent = '锻造工匠';
            forgeBtn.dataset.role = 'forge';
            
            const chefBtn = document.createElement('button');
            chefBtn.className = 'handbook-nav-btn';
            chefBtn.textContent = '厨师';
            chefBtn.dataset.role = 'chef';

            const spacer = document.createElement('div');
            spacer.className = 'nav-spacer';

            const instructionsBtn = document.createElement('button');
            instructionsBtn.className = 'handbook-nav-btn';
            instructionsBtn.textContent = '说明';
            instructionsBtn.dataset.role = 'instructions';

            const allBtns = [forgeBtn, chefBtn, instructionsBtn];
            allBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    allBtns.forEach(b => b.classList.remove('active'));
                    e.currentTarget.classList.add('active');
                    populateHandbook(e.currentTarget.dataset.role);
                });
            });
            
            handbookNav.appendChild(forgeBtn);
            handbookNav.appendChild(chefBtn);
            handbookNav.appendChild(spacer);
            handbookNav.appendChild(instructionsBtn);
            
            populateHandbook('forge');
        }

        function hideHandbook() {
            handbookScreen.style.display = 'none';
            roleSelectionScreen.style.display = 'block';
        }

        function populateHandbook(roleKey) {
            handbookContent.innerHTML = '';
            if (roleKey === 'instructions') {
                populateInstructions();
                return;
            }

            const role = ROLES[roleKey];
            const roleSection = document.createElement('div');
            
            // Card Library
            const librarySection = document.createElement('div');
            const libraryTitle = document.createElement('h3');
            libraryTitle.textContent = role.cardPoolTitle;
            librarySection.appendChild(libraryTitle);
            const libraryContainer = document.createElement('div');
            libraryContainer.style.display = 'flex';
            libraryContainer.style.flexWrap = 'wrap';
            libraryContainer.style.gap = '10px';
            for(const cardName in role.library) {
                const cardItem = document.createElement('div');
                cardItem.className = 'handbook-card-item';
                const cardEl = createCardElement(role.library[cardName], 'handbook', null, role);
                const countEl = document.createElement('span');
                countEl.className = 'handbook-card-count';
                countEl.textContent = `x${role.library[cardName].count}`;
                cardItem.appendChild(cardEl);
                cardItem.appendChild(countEl);
                libraryContainer.appendChild(cardItem);
            }
            librarySection.appendChild(libraryContainer);
            roleSection.appendChild(librarySection);

            // Recommended Decks
            const recSection = document.createElement('div');
            const recTitle = document.createElement('h3');
            recTitle.textContent = '策略卡组一览';
            recSection.appendChild(recTitle);
            
            for(const recipeName in role.recipes) {
                const recipe = role.recipes[recipeName];
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'handbook-recipe-item';
                recipeDiv.innerHTML = `<h4>${recipeName} <span class="recipe-label rarity-${recipe.rarityKey}">${recipe.difficulty}</span></h4>`;
                
                const strategyContainer = document.createElement('div');
                strategyContainer.className = 'handbook-strategy-container';

                const tabsDiv = document.createElement('div');
                tabsDiv.className = 'handbook-recipe-tabs';

                const deckContainer = document.createElement('div');
                deckContainer.className = 'handbook-recipe-deck';
                deckContainer.style.display = 'flex';

                const strategyTypes = { recommended: '推荐', high: '高分', stable: '稳定', burst: '爆发' };
                for (const type in strategyTypes) {
                    const tabBtn = document.createElement('button');
                    tabBtn.className = 'handbook-recipe-tab';
                    tabBtn.dataset.strategy = type;
                    tabBtn.textContent = strategyTypes[type];
                    if (recipe.strategies.recommended === type && type !== 'recommended') {
                         tabBtn.textContent += ' ★';
                    }

                    tabBtn.addEventListener('click', (e) => {
                        tabsDiv.querySelectorAll('.handbook-recipe-tab').forEach(t => t.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        
                        let deckKey = type;
                        if (type === 'recommended') {
                            deckKey = recipe.strategies.recommended;
                        }
                        const deck = recipe.strategies[deckKey];
                        deckContainer.innerHTML = '';
                        deck.forEach(cardName => {
                            const cardInfo = role.library[cardName];
                            const cardEl = createCardElement(cardInfo, 'handbook', null, role);
                            cardEl.style.transform = 'scale(0.8)';
                            cardEl.style.margin = '-10px 0';
                            deckContainer.appendChild(cardEl);
                        });
                    });
                    tabsDiv.appendChild(tabBtn);
                }
                
                strategyContainer.appendChild(tabsDiv);
                strategyContainer.appendChild(deckContainer);
                recipeDiv.appendChild(strategyContainer);
                recSection.appendChild(recipeDiv);

                // Set initial active tab and render initial deck
                tabsDiv.querySelector('.handbook-recipe-tab[data-strategy="recommended"]').classList.add('active');
                
                const initialDeckKey = recipe.strategies.recommended;
                const initialDeck = recipe.strategies[initialDeckKey];
                initialDeck.forEach(cardName => {
                    const cardInfo = role.library[cardName];
                    const cardEl = createCardElement(cardInfo, 'handbook', null, role);
                    cardEl.style.transform = 'scale(0.8)';
                    cardEl.style.margin = '-10px 0';
                    deckContainer.appendChild(cardEl);
                });
            }
            roleSection.appendChild(recSection);

            handbookContent.appendChild(roleSection);
        }

        function populateInstructions() {
            handbookContent.innerHTML = `
                <div class="handbook-section">
                    <h3>卡组策略说明</h3>
                    <p><strong>推荐 ★</strong>: 综合考量高分潜力和稳定性，由算法为你选出的最优解。</p>
                    <p><strong>高分</strong>: 追求极限数值成长，通常放弃稳定性和均衡，风险高但上限也高。</p>
                    <p><strong>稳定</strong>: 优先保证分数的均衡增长，下限极高，能稳定产出高品质作品，但难以冲击极限分数。</p>
                    <p><strong>爆发</strong>: 前期积累，后期通过乘法卡牌（如点火、调味）一锤定音，追求瞬间的巨大分数增长，视觉效果震撼，但对抽卡顺序要求苛刻。</p>
                </div>
                <div class="handbook-section">
                    <h3>星级规则一览</h3>
                    ${Object.keys(ROLES).map(roleKey => {
                        const role = ROLES[roleKey];
                        return `
                            <div class="handbook-role-rules">
                                <h4>${role.title.replace('模拟器', '')}</h4>
                                <ul>
                                    ${Object.keys(role.recipes).map(recipeName => {
                                        const recipe = role.recipes[recipeName];
                                        let ratingText = '';
                                        let lowerBound = 0;
                                        recipe.ratings.forEach((threshold, index) => {
                                            const upperBoundText = (index + 1 < recipe.ratings.length) ? recipe.ratings[index+1] - 1 : '以上';
                                            const scoreRange = (upperBoundText === '以上') ? `${threshold} 分以上` : `${threshold} - ${upperBoundText} 分`;
                                            ratingText += `<li><strong>${'★'.repeat(index+1)}${'☆'.repeat(recipe.ratings.length - (index+1))}:</strong> ${scoreRange}</li>`;
                                        });
                                        return `<li><strong>${recipeName}:</strong><ul>${ratingText}</ul></li>`;
                                    }).join('')}
                                </ul>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function generateBackground(role) {
            backgroundContainer.innerHTML = ''; // Clear previous
            const count = 40;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('div');
                const size = Math.random() * (role === 'forge' ? 4 : 12) + 2;
                el.style.width = `${size}px`;
                el.style.height = `${size}px`;
                el.style.left = `${Math.random() * 100}%`;
                const duration = Math.random() * 10 + 8;
                el.style.animationDuration = `${duration}s`;
                const delay = Math.random() * 8;
                el.style.animationDelay = `${delay}s`;

                if (role === 'forge') {
                    el.className = 'spark';
                } else {
                    el.className = 'bubble';
                }
                backgroundContainer.appendChild(el);
            }
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        init();
    </script>
</body>
</html>
